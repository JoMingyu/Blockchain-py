# min-blockchain
A simple PoW Blockchain in Python

## BlockChain
블록체인은 초기의 블록(Genesis Block)부터 시작해서 바로 앞의 블록에 대한 링크를 가지고 있는(여러 블록이 순차적으로 묶인) linked list이다. 블록에는 거래 정보가 기록되어 있다. 블록체인은 여러 노드(특히 채굴자)에 걸쳐 분산되어 저장 및 관리되며, 따라서 블록의 집합인 블록체인은 모든 거래 정보를 포함하는 거대한 분산(공용) 장부라고 볼 수 있다.

## Block
블록은 블록체인의 원소로서, 블록의 본문에는 거래 정보(transaction)의 묶음(비트코인의 경우 수십~수백 개)이 포함된다. 블록에는 헤더가 존재하는데, 기본적으로 6개의 정보(version, previous block hash, merkle root, timestamp, bits, nonce)로 구성된다.
### Block Header
- version : 소프트웨어/프로토콜 버전
- previous block hash : linked list 형태로 블록을 체이닝하기 위한 데이터. 해당 블록의 바로 앞에 위치하는 블록의 블록 해쉬
- merkle hash : 개별 거래 정보의 거래 해쉬를 2진 트리(머클 트리) 형태로 구성할 때, 트리 루트에 위치하는 해쉬값
- time : 블록이 생성된 시간
- bits : 작업 난이도
- nonce : PoW 알고리즘에서 채굴 과정을 위해 사용되는 변수. 블록 헤더에서 유일하게 변화시킬 수 있는 데이터.
### Block Hash
블록의 식별자 역할을 하는 블록 해쉬는 위의 6가지 블록 헤더 정보를 입력값으로 하고, 여기에 SHA256 해시 함수를 2회 적용해서 계산되는 값으로 32바이트의 숫자값이다. 이 값은 블록 전체를 해쉬한 것이 아니라, 블록 헤더를 해쉬한 값이다.

그렇다면, 개별 거래가 생겨났을 때 이 거래들은 각자의 해쉬값이 생기며 이들이 모여 머클 트리를 이루고 이 트리에 해당하는 해쉬값이 생겨나게 된다. 그리고 나머지 헤더의 요소(버전, 앞 블록의 블록 해쉬, 생성시각 등)와 모여 블록 헤더를 이루게 된다. 이에 2회의 SHA256 해시를 거치면 블록 해쉬를 얻어낼 수 있다. 그러나 이 블록 해쉬가 유효한지는 작업 증명 과정이 더 필요하다.
### Block Body
Block Body에 들어가는 데이터는 간단하다. Merkle Tree 형식으로 송신자(sender), 수신자(recipient), 액수(amount)로 이루어진 거래 데이터가 저장된다. 블록 헤더에는 이 머클 트리의 루트 해쉬값이 저장된다.

## Proof of Work(작업 증명) or Mining(채굴)
작업 증명은 새로운 블록을 블록체인에 추가하는 작업을 완료했음을 증명하는 것이다. '새로운 블록을 블록체인에 추가한다'는 것은, 그동안 진행된 거래를 유효한 것으로 만들어 공식화한다는 것을 뜻한다. 새로운 블록을 블록체인에 추가하려면, 그 새로운 블록의 해쉬의 값이 특정 숫자보다 작아지게 만드는 임의의 숫자 X를 찾아야 한다. 그 숫자 X는 블록의 헤더에서 유일하게 변화시킬 수 있는, nonce 값을 변화시키며 찾는다. 결론적으로 이 nonce 값을 구하는 것이 바로 작업 증명이다. 한 블록에 유효한 nonce를 가장 먼저 찾은 채굴자에게 보상이 주어지며, 즉시 다음 블록이 진행된다. N-1번 블록이 생성되었다는 소식을 접한 각 노드는 이 정보(previous block hash)를 바탕으로 즉시 N번 블록을 채굴하기 시작하는 것이다.
### nonce
역산 불가능한 해쉬 함수의 특성 상, 어떤 해쉬값 A를 결과로 나오게 하는 입력값을 찾으려면 결과가 A가 될 때까지 무작위로 입력값을 계속 바꿔가면서 찾아내야 한다. 그 입력 값을 바꿀 수 있는 유일한 통로가 헤더에서 유일하게 확정되지 않은 값인 nonce이다. 그렇다면, 작업 증명자(채굴자)의 입장에서는 블록 헤더의 nonce를 바꿔가며 블록 해쉬를 찾아내게 된다. nonce가 적게는 수백 개, 많게는 수억 개씩 올라가며 블록 해시를 만들어내며, 작업 증명의 성공 여부를 판단한다. 작업 증명(채굴)은 복잡한 수학 문제를 푼다고 이야기를 하지만, 사실상 brute force로 nonce값을 계속 변화시키며 유효한 해시를 찾아내는 과정일 뿐이다.
### 작업 증명 성공 여부
한 블록의 해쉬 결과가 A라고 치면, 많은 작업 증명자들은 nonce를 늘려가며 작업 증명 성공 여부를 비교한다. 그럼 해쉬 결과인 A는 어떻게 결정되는 것일까.

바로 블록 헤더의 bits(작업 난이도)에 의해 결정된다. 블록 해쉬가 특정 숫자보다 낮게 나올 때의 nonce 값을 찾아내는 것이 작업 증명인데, bits는 nonce 값 계산의 난이도(블록 해쉬의 낮은 정도)를 나타낸다. 앞에서 블록 해쉬는 32바이트의 숫자라고 했는데, 일단 블록 해쉬를 부호 없는 1바이트의 숫자라고 쳐 보자. 그럼 1바이트의 숫자값을 블록 해쉬값으로 산출하는 해쉬 함수는 0 ~ 255 사이의 값을 결과로 산출한다. 블록 해쉬가 128보다 작아야 한다고 치면, 해쉬 함수를 적용하여 128보다 작은 블록 해쉬값이 나올 확률은 50%이다. 블록 해쉬가 64보다 작아야 한다면 25%, 32보다 작아야 한다면 12.5%로 줄어든다. 여기서 128, 64, 32라는 특정 숫자가 바로 블록 헤더 정보의 bits라고 볼 수 있다. 따라서 마이닝에 가장 중요한 건 이 nonce와 bits이다.
### 보상
보상은 새로 발행되는 코인과 해당 블록에 포함되는 거래 수수료를 포함한다. 예를 들어 비트코인의 발행은, 채굴자가 블록을 처음 구성할 때 채굴자의 지갑으로 일정량의 비트코인이 입금되는 거래를 그 블록의 첫 거래(generation transaction)로 추가하는 방식으로 시작했다. 새로 발행되는 비트코인은 최초에 50BTC에서 시작하였고 블록체인에 21만개의 블록이 추가될 때마다 절반으로 줄어든다. 보상은 nonce 값을 찾아내고, 그 결과로 새로운 블록을 블록체인에 추가해서, 해당 블록에 포함된 모든 거래를 유효한 거래로 확정시켜 준 대가라고 할 수 있다.

## Node
.

## 거래기록의 보호
거래 기록이 담긴 블록을 굳이 수많은 작업 증명 과정을 통해 공식화하여 블록체인에 추가하는 이유는, 거래 기록을 보호하기 위해서이다. 모든 거래기록이 공유되는 상황에서 해커들이 쉽게 이 기록을 조작하는 것을 방지해야 하기 때문이다. 예를 들어 비트코인 시스템에서는, 블록체인이 진짜인지 가짜인지를 민주주의의 원칙에 의하여 결정한다. 블록체인의 복사본은 모든 노드들이 가지고 있는데, 여러가지 이유로 서로 다른 복사본을 가지고 있다(forked). 이 때 가장 많은 노드들이 가지고 있는 복사본을 진짜로 여기는 것이다. 만약 블록을 쉽게 공식화할 수 있다면 해커가 많은 숫자의 컴퓨터만 가지고도 기록의 조작이 가능해지는 것이다. 하지만 nonce를 찾기가 매우 어렵게 만듬으로써 블록체인을 조작하려면 해커는 채굴자가 가진 CPU 파워보다 더 큰 파워(51% 이상)를 가져야 한다. 특히 해커가 조작하고자 하는 블록 이후에 여러개의 블록이 이어진 경우에는 조작이 현실적으로 불가능하다.
### 채굴과 선순환 구조
모든 거래는 블록에 기록되고, 채굴자는 블록을 유효하게 만들기 위하여 컴퓨팅 파워를 집중하고, 블록이 추가되면 채굴자에게 인센티브를 제공한다. 암호화폐의 가치가 유지되도록 하는 선순환적인 시스템이다.
